<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Scanner App Mobile</title>
    
    <script src="https://docs.opencv.org/4.7.0/opencv.js" async onload="onOpenCvReady();"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* Reset y Base */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0; padding: 0; 
            background: #000; 
            color: white; 
            height: 100dvh; /* Altura din√°mica real del m√≥vil */
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* √Årea de C√°mara (Viewfinder) */
        #viewport {
            position: relative;
            flex: 1;
            width: 100%;
            overflow: hidden;
            background: #000;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Llena la pantalla recortando excesos */
            display: block;
        }

        #canvasOverlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        /* Flash Effect */
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 50;
            transition: opacity 0.1s ease-out;
        }

        /* UI Layer (HUD) */
        #hud {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.4) 60%, transparent 100%);
            padding-bottom: env(safe-area-inset-bottom, 20px); /* iPhone X+ safe area */
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 20;
        }

        /* Galer√≠a Horizontal */
        #gallery {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 0 20px;
            scrollbar-width: none; /* Firefox */
        }
        #gallery::-webkit-scrollbar { display: none; } /* Chrome/Safari */

        .thumb-wrapper {
            position: relative;
            flex: 0 0 auto;
            width: 60px; height: 80px;
            border-radius: 6px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            transition: transform 0.2s;
        }
        .thumb-wrapper img { width: 100%; height: 100%; object-fit: cover; }
        .thumb-count {
            position: absolute; top: 0; right: 0;
            background: #ff3b30; color: white;
            font-size: 10px; padding: 2px 5px;
            border-bottom-left-radius: 4px;
        }

        /* Controles Principales */
        .controls-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px 20px 30px 20px;
        }

        /* Botones Estilizados */
        .btn-icon {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border: none;
            color: white;
            width: 44px; height: 44px;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 20px;
            cursor: pointer;
        }
        .btn-icon:active { background: rgba(255,255,255,0.3); }

        .shutter-btn {
            width: 72px; height: 72px;
            border-radius: 50%;
            border: 4px solid white;
            background: transparent;
            position: relative;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
        }
        .shutter-inner {
            width: 60px; height: 60px;
            background: white;
            border-radius: 50%;
            transition: transform 0.1s;
        }
        .shutter-btn:active .shutter-inner { transform: scale(0.9); background: #ddd; }

        .btn-text {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            display: flex; align-items: center; gap: 6px;
        }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top: 4px solid #007aff; border-radius: 50%;
            animation: spin 1s infinite linear;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* Iconos SVG simples en CSS */
        .icon-trash::before { content: 'üóëÔ∏è'; font-size: 18px; filter: grayscale(1); }
        .icon-pdf::before { content: 'üìÑ'; }
    </style>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <p style="margin-top: 20px; color: #888; font-size: 14px;">Iniciando Sistema...</p>
</div>

<div id="viewport">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvasOverlay"></canvas>
    <div id="flash"></div>
</div>

<div id="hud">
    <div id="gallery"></div>

    <div class="controls-row">
        <button class="btn-icon icon-trash" onclick="resetGallery()"></button>
        
        <button class="shutter-btn" onclick="triggerCapture()">
            <div class="shutter-inner"></div>
        </button>

        <button class="btn-text" onclick="generatePDF()">
            <span>PDF</span>
            <span id="pdf-badge" style="background:rgba(0,0,0,0.2); padding: 2px 6px; border-radius:10px; font-size:12px;">0</span>
        </button>
    </div>
</div>

<canvas id="canvasProcess" style="display:none;"></canvas>

<script>
    // --- Configuraci√≥n y Estado ---
    const CONFIG = {
        processWidth: 480, // Downscale para detecci√≥n r√°pida
        outputQuality: 0.8
    };

    let state = {
        cvReady: false,
        stream: null,
        pages: [], // Array de dataURLs
        currentContour: null, // Puntos detectados
        isCapturing: false
    };

    const els = {
        video: document.getElementById('video'),
        overlay: document.getElementById('canvasOverlay'),
        ctxOverlay: document.getElementById('canvasOverlay').getContext('2d'),
        flash: document.getElementById('flash'),
        gallery: document.getElementById('gallery'),
        badge: document.getElementById('pdf-badge'),
        loader: document.getElementById('loader')
    };

    // --- Inicializaci√≥n ---
    function onOpenCvReady() {
        state.cvReady = true;
        initCamera();
    }

    async function initCamera() {
        try {
            // Pedimos resoluci√≥n alta, preferimos c√°mara trasera
            const constraints = {
                audio: false,
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 }
                }
            };
            
            state.stream = await navigator.mediaDevices.getUserMedia(constraints);
            els.video.srcObject = state.stream;
            
            els.video.onloadedmetadata = () => {
                els.video.play();
                els.loader.style.opacity = '0';
                setTimeout(() => els.loader.style.display = 'none', 500);
                
                // Ajustar tama√±o del overlay al video real renderizado
                resizeOverlay();
                window.addEventListener('resize', resizeOverlay);
                
                // Iniciar loop de detecci√≥n
                requestAnimationFrame(processLoop);
            };
        } catch (err) {
            alert("No se pudo acceder a la c√°mara. Aseg√∫rate de estar en HTTPS.");
            console.error(err);
        }
    }

    function resizeOverlay() {
        els.overlay.width = els.video.videoWidth;
        els.overlay.height = els.video.videoHeight;
    }

    // --- Core: Detecci√≥n en Tiempo Real ---
    function processLoop() {
        if (!state.cvReady || els.video.paused || els.video.ended) {
            requestAnimationFrame(processLoop);
            return;
        }

        // 1. Setup b√°sico
        let cap = new cv.VideoCapture(els.video);
        let src = new cv.Mat(els.video.videoHeight, els.video.videoWidth, cv.CV_8UC4);
        cap.read(src);

        // 2. Escalar para velocidad (downsample)
        let smallSrc = new cv.Mat();
        let scale = CONFIG.processWidth / src.cols;
        cv.resize(src, smallSrc, new cv.Size(CONFIG.processWidth, src.rows * scale));

        // 3. Procesamiento de imagen
        cv.cvtColor(smallSrc, smallSrc, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(smallSrc, smallSrc, new cv.Size(5, 5), 0);
        cv.Canny(smallSrc, smallSrc, 75, 200);

        // 4. Encontrar contornos
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(smallSrc, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // 5. Filtrar cuadril√°teros
        let maxArea = 0;
        let foundContour = null;

        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            
            // √Årea m√≠nima para considerar documento
            if (area > 5000) { 
                let peri = cv.arcLength(cnt, true);
                let approx = new cv.Mat();
                cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                
                if (approx.rows === 4 && area > maxArea) {
                    maxArea = area;
                    if(foundContour) foundContour.delete();
                    foundContour = approx;
                } else {
                    approx.delete();
                }
            }
        }

        // 6. Dibujar resultado
        els.ctxOverlay.clearRect(0, 0, els.overlay.width, els.overlay.height);
        
        if (foundContour) {
            // Escalar puntos de vuelta al tama√±o original
            let pts = [];
            for(let i=0; i<4; i++) {
                pts.push({
                    x: foundContour.data32S[i*2] / scale,
                    y: foundContour.data32S[i*2+1] / scale
                });
            }
            state.currentContour = pts;

            // Dibujar gu√≠a visual
            els.ctxOverlay.beginPath();
            els.ctxOverlay.lineWidth = 6;
            els.ctxOverlay.strokeStyle = '#00e676'; // Material Green
            els.ctxOverlay.moveTo(pts[0].x, pts[0].y);
            for(let i=1; i<4; i++) els.ctxOverlay.lineTo(pts[i].x, pts[i].y);
            els.ctxOverlay.closePath();
            els.ctxOverlay.stroke();

            // Relleno semitransparente para feedback positivo
            els.ctxOverlay.fillStyle = 'rgba(0, 230, 118, 0.2)';
            els.ctxOverlay.fill();
            
            foundContour.delete();
        } else {
            state.currentContour = null;
        }

        // Limpieza de memoria
        src.delete(); smallSrc.delete(); 
        contours.delete(); hierarchy.delete();

        requestAnimationFrame(processLoop);
    }

    // --- Captura y Procesamiento ---
    function triggerCapture() {
        if (state.isCapturing) return;
        state.isCapturing = true;

        // Feedback h√°ptico y visual
        if (navigator.vibrate) navigator.vibrate(50);
        els.flash.style.opacity = '0.8';
        setTimeout(() => els.flash.style.opacity = '0', 150);

        // Capturar frame completo
        let canvas = document.createElement('canvas');
        canvas.width = els.video.videoWidth;
        canvas.height = els.video.videoHeight;
        canvas.getContext('2d').drawImage(els.video, 0, 0);
        
        let src = cv.imread(canvas);
        let dst = new cv.Mat();

        try {
            if (state.currentContour) {
                // WARP PERSPECTIVE
                let pts = sortPoints(state.currentContour);
                
                // Calcular dimensiones destino
                let width = Math.max(
                    Math.hypot(pts[2].x - pts[3].x, pts[2].y - pts[3].y),
                    Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y)
                );
                let height = Math.max(
                    Math.hypot(pts[1].x - pts[2].x, pts[1].y - pts[2].y),
                    Math.hypot(pts[0].x - pts[3].x, pts[0].y - pts[3].y)
                );

                let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    pts[0].x, pts[0].y, pts[1].x, pts[1].y,
                    pts[2].x, pts[2].y, pts[3].x, pts[3].y
                ]);
                let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    0, 0, width, 0, width, height, 0, height
                ]);

                let M = cv.getPerspectiveTransform(srcTri, dstTri);
                cv.warpPerspective(src, dst, M, new cv.Size(width, height));
                
                srcTri.delete(); dstTri.delete(); M.delete();
            } else {
                // Fallback: Usar imagen completa
                src.copyTo(dst);
            }

            // APLICAR FILTRO FOTOCOPIA
            applyScanFilter(dst);

            // Guardar y mostrar
            cv.imshow(canvas, dst);
            const imgData = canvas.toDataURL('image/jpeg', CONFIG.outputQuality);
            addPage(imgData);

        } catch (e) {
            console.error("Error en procesamiento", e);
        } finally {
            src.delete(); dst.delete();
            state.isCapturing = false;
        }
    }

    function sortPoints(pts) {
        // Ordenar: TL, TR, BR, BL
        pts.sort((a,b) => a.y - b.y);
        let top = pts.slice(0,2).sort((a,b) => a.x - b.x);
        let bottom = pts.slice(2,4).sort((a,b) => a.x - b.x);
        return [top[0], top[1], bottom[1], bottom[0]];
    }

    function applyScanFilter(mat) {
        cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY);
        // Filtro adaptativo para eliminar sombras y limpiar texto
        cv.adaptiveThreshold(mat, mat, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 15, 12);
    }

    // --- Gesti√≥n de Galer√≠a y PDF ---
    function addPage(dataUrl) {
        state.pages.push(dataUrl);
        
        // Crear elemento UI
        let div = document.createElement('div');
        div.className = 'thumb-wrapper';
        div.innerHTML = `<img src="${dataUrl}">`;
        
        // Efecto visual de entrada
        div.style.transform = 'scale(0)';
        els.gallery.appendChild(div);
        setTimeout(() => div.style.transform = 'scale(1)', 50);

        // Scroll al final
        els.gallery.scrollTo({ left: els.gallery.scrollWidth, behavior: 'smooth' });
        
        updateCount();
    }

    function updateCount() {
        els.badge.innerText = state.pages.length;
    }

    function resetGallery() {
        if(state.pages.length > 0 && confirm("¬øBorrar todos los escaneos?")) {
            state.pages = [];
            els.gallery.innerHTML = '';
            updateCount();
        }
    }

    async function generatePDF() {
        if (state.pages.length === 0) return alert("Captura al menos una p√°gina.");
        
        // Feedback visual
        let originalText = document.querySelector('.btn-text span').innerText;
        document.querySelector('.btn-text span').innerText = "Generando...";
        
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        for (let i = 0; i < state.pages.length; i++) {
            let imgData = state.pages[i];
            let img = new Image();
            img.src = imgData;
            await new Promise(r => img.onload = r);

            let imgProps = doc.getImageProperties(imgData);
            let pdfWidth = doc.internal.pageSize.getWidth();
            let pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

            if (i > 0) doc.addPage();
            doc.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
        }
        
        // Nombre de archivo con fecha
        const fileName = `Scan_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.pdf`;
        doc.save(fileName);
        
        document.querySelector('.btn-text span').innerText = originalText;
    }
</script>
</body>
</html>
