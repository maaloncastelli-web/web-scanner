<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web Scanner Pro</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --accent: #00e5ff;
            --bg: #0f172a;
            --surface: #1e293b;
            --text: #f8fafc;
            --safe-bottom: env(safe-area-inset-bottom);
            --app-height: 100dvh; 
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; padding: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            height: var(--app-height);
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* HEADER */
        .app-header {
            height: 60px;
            padding: 0 15px;
            background: var(--surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 20;
            flex-shrink: 0;
            padding-top: env(safe-area-inset-top);
        }

        /* BOTONES */
        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
        }
        .btn.secondary { background: #475569; }
        .btn.accent { background: var(--accent); color: #000; }
        .btn:active { transform: scale(0.96); }

        /* VISTAS */
        .view {
            flex: 1;
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }
        .view.active { display: flex; }

        /* --- HOME --- */
        #gallery-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            overflow-y: auto;
            padding-bottom: 120px; 
        }

        .thumb-card {
            background: var(--surface);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            aspect-ratio: 1/1.4;
            border: 1px solid #334155;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .thumb-card img { width: 100%; height: 100%; object-fit: cover; }
        .thumb-card .page-num {
            position: absolute; bottom: 5px; right: 5px;
            background: rgba(0,0,0,0.7); color: white;
            padding: 2px 6px; font-size: 10px; border-radius: 4px;
        }
        
        .empty-state {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; color: #64748b; width: 80%;
        }

        .fab-container {
            position: absolute; bottom: 30px; right: 20px;
            display: flex; gap: 15px;
            padding-bottom: var(--safe-bottom);
            z-index: 30;
        }
        .fab {
            width: 60px; height: 60px; border-radius: 50%; border: none;
            background: var(--accent); color: #000; font-size: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0, 0.4);
            display: flex; align-items: center; justify-content: center;
        }

        /* --- CÁMARA --- */
        #video-container { flex: 1; background: black; position: relative; }
        #video-feed { width: 100%; height: 100%; object-fit: cover; }
        .camera-controls {
            position: absolute; bottom: 0; left: 0; width: 100%;
            padding: 20px; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            display: flex; justify-content: space-around; align-items: center;
            padding-bottom: calc(20px + var(--safe-bottom));
        }
        .capture-btn {
            width: 72px; height: 72px; border-radius: 50%;
            border: 4px solid white; background: rgba(255,255,255,0.2);
        }

        /* --- EDITOR (Recorte) --- */
        #editor-container {
            flex: 1; background: #000; position: relative;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }
        #image-canvas {
            max-width: 95%; max-height: 95%;
            display: block; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #overlay-svg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }
        .selection-polygon {
            fill: rgba(0, 229, 255, 0.15); stroke: var(--accent);
            stroke-width: 2; vector-effect: non-scaling-stroke;
        }
        .crop-handle {
            fill: var(--accent); stroke: #fff; stroke-width: 3;
            r: 15; /* Manijas grandes para facilitar el toque */
            pointer-events: all; transition: transform 0.1s;
        }
        .crop-handle:active { transform: scale(1.3); fill: #fff; }

        .editor-footer {
            background: var(--surface);
            display: flex; justify-content: space-between; align-items: center;
            padding: 15px 20px;
            padding-bottom: calc(15px + var(--safe-bottom));
            z-index: 20;
        }

        /* --- VISTA PREVIEW (Filtros) --- */
        #preview-container {
            flex: 1; background: #111;
            display: flex; align-items: center; justify-content: center;
        }
        #preview-image {
            max-width: 90%; max-height: 90%;
            object-fit: contain;
            border: 1px solid #333;
        }
        
        .filter-tabs {
            display: flex; justify-content: center; gap: 10px;
            padding: 15px; background: var(--surface);
        }
        .filter-btn {
            background: #334155; color: #ccc; border: none;
            padding: 8px 12px; border-radius: 20px; font-size: 13px;
        }
        .filter-btn.active {
            background: var(--accent); color: black; font-weight: bold;
        }

        /* LOADER */
        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(15, 23, 42, 0.98); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.1);
            border-left-color: var(--accent); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 15px;">Iniciando Motor de Escaneo...</p>
    </div>

    <div id="view-home" class="view active">
        <div class="app-header">
            <span style="font-weight:bold; font-size:1.2rem;">DocScanner</span>
            <span id="page-counter">0 Páginas</span>
        </div>
        
        <div id="gallery-grid">
            <div class="empty-state" id="empty-msg">
                <p>Tu lista está vacía.</p>
                <p>Toca <b>+</b> para escanear.</p>
            </div>
        </div>

        <div class="fab-container">
            <button class="fab" onclick="generatePDF()" style="background: #ef4444; color: white;">PDF</button>
            <button class="fab" onclick="startCamera()">+</button>
            <input type="file" id="file-input" accept="image/*" style="display:none" onchange="handleFileUpload(this)">
        </div>
    </div>

    <div id="view-camera" class="view">
        <div id="video-container">
            <video id="video-feed" autoplay playsinline></video>
        </div>
        <div class="camera-controls">
            <button class="btn secondary" onclick="document.getElementById('file-input').click()">Galería</button>
            <button class="capture-btn" onclick="captureImage()"></button>
            <button class="btn secondary" onclick="switchView('view-home')">Cerrar</button>
        </div>
        <canvas id="hidden-canvas" style="display:none;"></canvas>
    </div>

    <div id="view-editor" class="view">
        <div class="app-header">
            <span>Ajustar Bordes</span>
        </div>
        <div id="editor-container">
            <canvas id="image-canvas"></canvas>
            <svg id="overlay-svg">
                <polygon id="crop-polygon" class="selection-polygon" points=""></polygon>
                <circle id="p0" class="crop-handle"></circle>
                <circle id="p1" class="crop-handle"></circle>
                <circle id="p2" class="crop-handle"></circle>
                <circle id="p3" class="crop-handle"></circle>
            </svg>
        </div>
        <div class="editor-footer">
            <button class="btn secondary" onclick="retakePhoto()">Atrás</button>
            <button class="btn accent" onclick="goToPreview()">Siguiente</button>
        </div>
    </div>

    <div id="view-preview" class="view">
        <div class="app-header">
            <span>Elegir Filtro</span>
        </div>
        
        <div id="preview-container">
            <img id="preview-image" src="" alt="Vista previa">
        </div>

        <div style="background: var(--surface);">
            <div class="filter-tabs">
                <button class="filter-btn" onclick="applyFilter('original')">Original</button>
                <button class="filter-btn" onclick="applyFilter('gray')">Gris</button>
                <button class="filter-btn active" onclick="applyFilter('bw')">Escáner (B/N)</button>
            </div>
            
            <div class="editor-footer">
                <button class="btn secondary" onclick="switchView('view-editor')">Reajustar</button>
                <button class="btn accent" onclick="savePage()">Guardar Página</button>
            </div>
        </div>
    </div>

    <script>
        // --- ESTADO ---
        let cvReady = false;
        let scannedPages = [];
        let currentStream = null;
        
        // Variables OpenCV
        let originalMat = null; // La imagen original completa
        let warpedMat = null;   // La imagen recortada (sin filtro)
        
        // UI State
        let displayedScale = 1;
        let cropPoints = [{x:0, y:0}, {x:0, y:0}, {x:0, y:0}, {x:0, y:0}];
        let activeHandleIndex = -1;
        let currentFilterMode = 'bw'; // Default

        // --- INICIO ---
        function onOpenCvReady() {
            cvReady = true;
            document.getElementById('loader').style.display = 'none';
        }

        function switchView(viewId) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            
            // Limpiar cámara si salimos de ella
            if (viewId !== 'view-camera' && currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
        }

        // --- CÁMARA & INPUT ---
        async function startCamera() {
            if (!cvReady) return alert("Cargando motor...");
            switchView('view-camera');
            try {
                const constraints = { video: { facingMode: { ideal: "environment" }, width: { ideal: 1920 }, height: { ideal: 1080 } } };
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                document.getElementById('video-feed').srcObject = currentStream;
            } catch (err) {
                alert("Error cámara. Usa Galería.");
            }
        }

        function handleFileUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => initEditor(img);
                    img.src = e.target.result;
                };
                reader.readAsDataURL(input.files[0]);
            }
            input.value = '';
        }

        function captureImage() {
            const video = document.getElementById('video-feed');
            const canvas = document.getElementById('hidden-canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            
            const img = new Image();
            img.onload = () => initEditor(img);
            img.src = canvas.toDataURL('image/jpeg');
        }

        // --- EDITOR: DETECCIÓN Y RECORTE ---
        function initEditor(imageObj) {
            switchView('view-editor');
            
            // Limpieza memoria anterior
            if(originalMat) originalMat.delete();
            if(warpedMat) warpedMat.delete(); warpedMat = null;

            originalMat = cv.imread(imageObj);
            
            // Auto-Detección
            cropPoints = detectDocument(originalMat);
            
            renderEditorCanvas(imageObj);
        }

        function detectDocument(src) {
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let edges = new cv.Mat();
            let kernel = cv.Mat.ones(5, 5, cv.CV_8U);

            try {
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                cv.Canny(blurred, edges, 75, 200);
                cv.dilate(edges, edges, kernel); // Engrosar bordes

                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let maxArea = 0;
                let biggestContour = null;

                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    if (area > 5000) {
                        let peri = cv.arcLength(cnt, true);
                        let approx = new cv.Mat();
                        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                        if (area > maxArea && approx.rows === 4) {
                            maxArea = area;
                            biggestContour = approx.clone();
                        }
                        approx.delete();
                    }
                }

                let resultPoints;
                if (biggestContour) {
                    let pts = [];
                    for(let i=0; i<4; i++) pts.push({ x: biggestContour.data32S[i*2], y: biggestContour.data32S[i*2 + 1] });
                    resultPoints = sortPoints(pts);
                    biggestContour.delete();
                } else {
                    // Fallback: Marco completo
                    const w = src.cols, h = src.rows, m = 30;
                    resultPoints = [{x:m,y:m}, {x:w-m,y:m}, {x:w-m,y:h-m}, {x:m,y:h-m}];
                }

                contours.delete(); hierarchy.delete(); gray.delete(); blurred.delete(); edges.delete(); kernel.delete();
                return resultPoints;
            } catch (e) {
                return [{x:0,y:0}, {x:src.cols,y:0}, {x:src.cols,y:src.rows}, {x:0,y:src.rows}];
            }
        }

        function sortPoints(pts) {
            pts.sort((a,b) => a.y - b.y);
            let top = pts.slice(0, 2).sort((a,b) => a.x - b.x);
            let bottom = pts.slice(2, 4).sort((a,b) => a.x - b.x);
            return [top[0], top[1], bottom[1], bottom[0]];
        }

        // --- RENDERIZADO UI RECORTE ---
        function renderEditorCanvas(imageObj) {
            const canvas = document.getElementById('image-canvas');
            const container = document.getElementById('editor-container');
            const svg = document.getElementById('overlay-svg');
            
            const scaleX = container.clientWidth / imageObj.width;
            const scaleY = container.clientHeight / imageObj.height;
            displayedScale = Math.min(scaleX, scaleY) * 0.95; 

            canvas.width = imageObj.width * displayedScale;
            canvas.height = imageObj.height * displayedScale;
            
            canvas.getContext('2d').drawImage(imageObj, 0, 0, canvas.width, canvas.height);

            // Centrar SVG
            const left = (container.clientWidth - canvas.width) / 2;
            const top = (container.clientHeight - canvas.height) / 2;
            
            svg.style.width = canvas.width + 'px';
            svg.style.height = canvas.height + 'px';
            svg.style.left = left + 'px';
            svg.style.top = top + 'px';
            
            canvas.style.marginLeft = left + 'px';
            canvas.style.marginTop = top + 'px';

            updateOverlayGraphics();
        }

        function updateOverlayGraphics() {
            const polyString = cropPoints.map(p => `${p.x * displayedScale},${p.y * displayedScale}`).join(" ");
            document.getElementById('crop-polygon').setAttribute("points", polyString);
            cropPoints.forEach((p, i) => {
                const h = document.getElementById('p'+i);
                h.setAttribute("cx", p.x * displayedScale);
                h.setAttribute("cy", p.y * displayedScale);
            });
        }

        // --- INTERACCIÓN TÁCTIL ---
        const svgOverlay = document.getElementById('overlay-svg');
        const getCoords = (e) => {
            const rect = svgOverlay.getBoundingClientRect();
            const t = e.touches ? e.touches[0] : e;
            return { x: t.clientX - rect.left, y: t.clientY - rect.top };
        }

        const onStart = (e) => {
            e.preventDefault();
            const {x, y} = getCoords(e);
            let minDist = 50; // Área de toque generosa
            cropPoints.forEach((p, i) => {
                const dist = Math.hypot((p.x * displayedScale) - x, (p.y * displayedScale) - y);
                if (dist < minDist) { minDist = dist; activeHandleIndex = i; }
            });
        };

        const onMove = (e) => {
            if (activeHandleIndex === -1) return;
            e.preventDefault();
            const {x, y} = getCoords(e);
            let newX = Math.max(0, Math.min(originalMat.cols, x / displayedScale));
            let newY = Math.max(0, Math.min(originalMat.rows, y / displayedScale));
            cropPoints[activeHandleIndex] = {x: newX, y: newY};
            updateOverlayGraphics();
        };

        svgOverlay.addEventListener('touchstart', onStart, {passive:false});
        svgOverlay.addEventListener('touchmove', onMove, {passive:false});
        svgOverlay.addEventListener('touchend', () => activeHandleIndex = -1);
        svgOverlay.addEventListener('mousedown', onStart);
        svgOverlay.addEventListener('mousemove', onMove);
        svgOverlay.addEventListener('mouseup', () => activeHandleIndex = -1);

        // --- FASE 2: PREVIEW Y FILTROS ---
        function goToPreview() {
            // 1. Realizar la transformación de perspectiva (WARP)
            let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                cropPoints[0].x, cropPoints[0].y, cropPoints[1].x, cropPoints[1].y,
                cropPoints[2].x, cropPoints[2].y, cropPoints[3].x, cropPoints[3].y
            ]);
            
            const w1 = Math.hypot(cropPoints[1].x-cropPoints[0].x, cropPoints[1].y-cropPoints[0].y);
            const w2 = Math.hypot(cropPoints[2].x-cropPoints[3].x, cropPoints[2].y-cropPoints[3].y);
            const h1 = Math.hypot(cropPoints[3].x-cropPoints[0].x, cropPoints[3].y-cropPoints[0].y);
            const h2 = Math.hypot(cropPoints[2].x-cropPoints[1].x, cropPoints[2].y-cropPoints[1].y);
            const finalW = Math.max(w1, w2);
            const finalH = Math.max(h1, h2);

            let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0,0, finalW,0, finalW,finalH, 0,finalH]);
            let M = cv.getPerspectiveTransform(srcTri, dstTri);
            
            warpedMat = new cv.Mat();
            cv.warpPerspective(originalMat, warpedMat, M, new cv.Size(finalW, finalH));
            
            // Limpieza intermedia
            srcTri.delete(); dstTri.delete(); M.delete();

            // 2. Ir a vista de preview con el filtro por defecto
            switchView('view-preview');
            applyFilter('bw'); // Default: Modo Escáner
        }

        function applyFilter(type) {
            if (!warpedMat) return;
            currentFilterMode = type;

            // Actualizar botones UI
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.filter-btn[onclick="applyFilter('${type}')"]`).classList.add('active');

            let dst = new cv.Mat();
            
            if (type === 'original') {
                warpedMat.copyTo(dst);
            } else if (type === 'gray') {
                cv.cvtColor(warpedMat, dst, cv.COLOR_RGBA2GRAY);
            } else if (type === 'bw') {
                // Efecto Escáner: Escala de grises + Threshold Adaptativo
                cv.cvtColor(warpedMat, dst, cv.COLOR_RGBA2GRAY);
                // Parametros afinados para documentos: BlockSize 15, C 10
                cv.adaptiveThreshold(dst, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 15, 10);
            }

            cv.imshow('hidden-canvas', dst);
            document.getElementById('preview-image').src = document.getElementById('hidden-canvas').toDataURL('image/jpeg', 0.9);
            dst.delete();
        }

        function savePage() {
            const finalImage = document.getElementById('preview-image').src;
            scannedPages.push(finalImage);
            
            updateGallery();
            if(originalMat) originalMat.delete(); originalMat = null;
            if(warpedMat) warpedMat.delete(); warpedMat = null;
            
            switchView('view-home');
        }

        function updateGallery() {
            const grid = document.getElementById('gallery-grid');
            const empty = document.getElementById('empty-msg');
            document.getElementById('page-counter').innerText = `${scannedPages.length} Página(s)`;
            
            empty.style.display = scannedPages.length ? 'none' : 'block';
            grid.innerHTML = ''; grid.appendChild(empty);
            
            scannedPages.forEach((src, idx) => {
                const d = document.createElement('div');
                d.className = 'thumb-card';
                d.innerHTML = `<img src="${src}"><div class="page-num">${idx+1}</div>`;
                grid.appendChild(d);
            });
        }

        function retakePhoto() {
            if(originalMat) { originalMat.delete(); originalMat = null; }
            startCamera();
        }

        function generatePDF() {
            if (!scannedPages.length) return alert("Escanea algo primero.");
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            scannedPages.forEach((img, i) => {
                if(i>0) doc.addPage();
                const props = doc.getImageProperties(img);
                const pdfW = doc.internal.pageSize.getWidth();
                const pdfH = (props.height * pdfW) / props.width;
                doc.addImage(img, 'JPEG', 0, 0, pdfW, pdfH);
            });
            doc.save('scanner_pro.pdf');
        }
    </script>
</body>
</html>
