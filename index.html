<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scanner Pro Web</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --accent: #00e5ff;
            --bg: #0f172a;
            --surface: #1e293b;
            --text: #f8fafc;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; }
        
        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- UI Components --- */
        .app-header {
            padding: 15px;
            background: var(--surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
        }
        
        .btn.secondary { background: #475569; }
        .btn.accent { background: var(--accent); color: #000; }

        /* --- Views Management --- */
        .view {
            flex: 1;
            display: none; /* Hidden by default */
            flex-direction: column;
            position: relative;
            width: 100%;
            height: 100%;
        }

        .view.active { display: flex; }

        /* --- Home/Gallery View --- */
        #gallery-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            overflow-y: auto;
        }

        .thumb-card {
            background: var(--surface);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            aspect-ratio: 1/1.4;
            border: 1px solid #334155;
        }

        .thumb-card img { width: 100%; height: 100%; object-fit: cover; }
        
        .empty-state {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #64748b;
        }

        .fab-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
        }

        .fab {
            width: 56px; height: 56px;
            border-radius: 50%;
            border: none;
            background: var(--accent);
            color: #000;
            font-size: 24px;
            box-shadow: 0 4px 15px rgba(0,229,255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* --- Camera View --- */
        #video-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .camera-controls {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 30px;
        }

        .capture-btn {
            width: 70px; height: 70px;
            border-radius: 50%;
            border: 4px solid white;
            background: transparent;
        }
        .capture-btn:active { background: white; }

        /* --- Crop/Edit View --- */
        #editor-container {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Canvas Layers */
        #image-canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        #overlay-svg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; /* Allow clicks to pass through except on handles */
        }

        /* The Animation/Selection Area */
        .selection-polygon {
            fill: rgba(0, 229, 255, 0.2); /* Semi-transparent Cyan */
            stroke: var(--accent);
            stroke-width: 2;
            vector-effect: non-scaling-stroke;
        }

        .crop-handle {
            fill: var(--accent);
            stroke: white;
            stroke-width: 2;
            cursor: grab;
            pointer-events: all; /* Catch touch events */
            transition: r 0.2s ease;
        }
        .crop-handle:active { r: 15; fill: white; }

        .editor-footer {
            height: 70px;
            background: var(--surface);
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        /* --- Loading Overlay --- */
        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(15, 23, 42, 0.9);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-left-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 15px;">Cargando Motor de Visi칩n...</p>
    </div>

    <div id="view-home" class="view active">
        <div class="app-header">
            <span>Mis Documentos</span>
            <span id="page-counter">0 P치ginas</span>
        </div>
        
        <div id="gallery-grid">
            <div class="empty-state" id="empty-msg">
                <p>No hay p치ginas escaneadas.</p>
                <p>Toca + para comenzar.</p>
            </div>
        </div>

        <div class="fab-container">
            <button class="fab" onclick="generatePDF()" style="background: #ef4444; color: white;" title="Generar PDF">
                PDF
            </button>
            <button class="fab" onclick="startCamera()">+</button>
            <input type="file" id="file-input" accept="image/*" style="display:none" onchange="handleFileUpload(this)">
        </div>
    </div>

    <div id="view-camera" class="view">
        <video id="video-feed" autoplay playsinline></video>
        <div class="camera-controls">
            <button class="btn secondary" onclick="document.getElementById('file-input').click()">游늬 Galer칤a</button>
            <button class="capture-btn" onclick="captureImage()"></button>
            <button class="btn secondary" onclick="switchView('view-home')">Cancelar</button>
        </div>
        <canvas id="hidden-canvas" style="display:none;"></canvas>
    </div>

    <div id="view-editor" class="view">
        <div class="app-header">
            <button class="btn secondary" onclick="retakePhoto()">Reintentar</button>
            <span>Ajustar Bordes</span>
            <button class="btn accent" onclick="processCrop()">Confirmar</button>
        </div>
        
        <div id="editor-container">
            <canvas id="image-canvas"></canvas>
            <svg id="overlay-svg">
                <polygon id="crop-polygon" class="selection-polygon" points=""></polygon>
                <circle id="p0" class="crop-handle" r="10"></circle>
                <circle id="p1" class="crop-handle" r="10"></circle>
                <circle id="p2" class="crop-handle" r="10"></circle>
                <circle id="p3" class="crop-handle" r="10"></circle>
            </svg>
        </div>
    </div>

    <script>
        // --- Global State ---
        let cvReady = false;
        let scannedPages = []; // Stores Base64 images
        let currentStream = null;
        let originalMat = null; // OpenCV Mat
        let displayedScale = 1; // Ratio between Screen Size and Actual Image
        
        // Crop Points (TL, TR, BR, BL)
        let cropPoints = [
            {x:0, y:0}, {x:0, y:0}, {x:0, y:0}, {x:0, y:0}
        ];
        let activeHandleIndex = -1;

        // --- Initialization ---
        function onOpenCvReady() {
            cvReady = true;
            document.getElementById('loader').style.display = 'none';
            console.log("OpenCV.js Ready");
        }

        function switchView(viewId) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            
            // Cleanup camera if leaving camera view
            if (viewId !== 'view-camera' && currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
        }

        // --- Camera & Capture Logic ---
        async function startCamera() {
            if (!cvReady) { alert("El motor a칰n est치 cargando..."); return; }
            switchView('view-camera');
            
            try {
                const constraints = {
                    video: {
                        facingMode: { ideal: "environment" },
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                document.getElementById('video-feed').srcObject = currentStream;
            } catch (err) {
                console.error("Error c치mara:", err);
                alert("No se pudo acceder a la c치mara. Usa la opci칩n de Galer칤a.");
            }
        }

        function handleFileUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => initEditor(img);
                    img.src = e.target.result;
                };
                reader.readAsDataURL(input.files[0]);
            }
        }

        function captureImage() {
            const video = document.getElementById('video-feed');
            const canvas = document.getElementById('hidden-canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            const img = new Image();
            img.onload = () => initEditor(img);
            img.src = canvas.toDataURL('image/jpeg');
        }

        // --- Core Vision & Editor Logic ---
        function initEditor(imageObj) {
            switchView('view-editor');
            
            // Init OpenCV Mat
            originalMat = cv.imread(imageObj);
            
            // 1. Detect Contours/Edges
            const detectedPoints = detectDocument(originalMat);
            cropPoints = detectedPoints;

            // 2. Render to Canvas (Scaled to fit screen)
            renderEditorCanvas(imageObj);
        }

        function detectDocument(srcMat) {
            // Processing pipeline
            let dst = new cv.Mat();
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let edges = new cv.Mat();
            
            try {
                cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                cv.Canny(blurred, edges, 75, 200);

                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let maxArea = 0;
                let maxContourIndex = -1;

                // Find largest contour
                for (let i = 0; i < contours.size(); ++i) {
                    let area = cv.contourArea(contours.get(i));
                    if (area > maxArea) {
                        maxArea = area;
                        maxContourIndex = i;
                    }
                }

                // Default to full image if nothing found
                let resultPoints = [
                    {x: 0, y: 0}, 
                    {x: srcMat.cols, y: 0}, 
                    {x: srcMat.cols, y: srcMat.rows}, 
                    {x: 0, y: srcMat.rows}
                ];

                if (maxContourIndex !== -1) {
                    let cnt = contours.get(maxContourIndex);
                    let peri = cv.arcLength(cnt, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

                    if (approx.rows === 4) {
                        // Found a quad!
                        let pointsArray = [];
                        for(let i=0; i<4; i++) {
                            pointsArray.push({
                                x: approx.data32S[i*2],
                                y: approx.data32S[i*2 + 1]
                            });
                        }
                        resultPoints = sortPoints(pointsArray);
                    }
                    approx.delete();
                }

                // Cleanup
                contours.delete(); hierarchy.delete(); 
                gray.delete(); blurred.delete(); edges.delete(); dst.delete();

                return resultPoints;

            } catch (e) {
                console.error("OpenCV Error", e);
                return resultPoints; // Fallback
            }
        }

        // Geometric sort to order TL, TR, BR, BL
        function sortPoints(pts) {
            pts.sort((a,b) => a.y - b.y);
            
            // Get top 2 and bottom 2
            let top = pts.slice(0, 2).sort((a,b) => a.x - b.x);
            let bottom = pts.slice(2, 4).sort((a,b) => a.x - b.x);

            // TL, TR, BR, BL
            return [top[0], top[1], bottom[1], bottom[0]];
        }

        function renderEditorCanvas(imageObj) {
            const canvas = document.getElementById('image-canvas');
            const container = document.getElementById('editor-container');
            
            // Calculate scale to fit
            const maxWidth = container.clientWidth;
            const maxHeight = container.clientHeight;
            
            const scaleX = maxWidth / imageObj.width;
            const scaleY = maxHeight / imageObj.height;
            displayedScale = Math.min(scaleX, scaleY); // Fit Contain

            canvas.width = imageObj.width * displayedScale;
            canvas.height = imageObj.height * displayedScale;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(imageObj, 0, 0, canvas.width, canvas.height);

            // Update SVG Overlay dimensions
            const svg = document.getElementById('overlay-svg');
            svg.style.width = canvas.width + 'px';
            svg.style.height = canvas.height + 'px';

            updateOverlayGraphics();
        }

        // --- Interaction & Animation (SVG) ---
        function updateOverlayGraphics() {
            // Update polygon points
            const polyString = cropPoints.map(p => 
                `${p.x * displayedScale},${p.y * displayedScale}`
            ).join(" ");
            
            document.getElementById('crop-polygon').setAttribute("points", polyString);

            // Update Handles
            for(let i=0; i<4; i++) {
                const handle = document.getElementById('p'+i);
                handle.setAttribute("cx", cropPoints[i].x * displayedScale);
                handle.setAttribute("cy", cropPoints[i].y * displayedScale);
            }
        }

        // SVG Event Listeners for Dragging
        const svgOverlay = document.getElementById('overlay-svg');
        
        svgOverlay.addEventListener('touchstart', handleStart, {passive: false});
        svgOverlay.addEventListener('touchmove', handleMove, {passive: false});
        svgOverlay.addEventListener('touchend', () => activeHandleIndex = -1);
        
        // Mouse support for desktop testing
        svgOverlay.addEventListener('mousedown', handleStart);
        svgOverlay.addEventListener('mousemove', handleMove);
        svgOverlay.addEventListener('mouseup', () => activeHandleIndex = -1);

        function handleStart(e) {
            e.preventDefault();
            const {x, y} = getEventCoords(e);
            
            // Find closest handle
            let minDist = 1000;
            cropPoints.forEach((p, i) => {
                const px = p.x * displayedScale;
                const py = p.y * displayedScale;
                const dist = Math.hypot(px - x, py - y);
                if (dist < 40) { // Hit radius
                    if (dist < minDist) {
                        minDist = dist;
                        activeHandleIndex = i;
                    }
                }
            });
        }

        function handleMove(e) {
            if (activeHandleIndex === -1) return;
            e.preventDefault();
            const {x, y} = getEventCoords(e);
            
            // Update logic coord
            cropPoints[activeHandleIndex].x = x / displayedScale;
            cropPoints[activeHandleIndex].y = y / displayedScale;
            
            // Visual Update (Animation)
            updateOverlayGraphics();
        }

        function getEventCoords(e) {
            const svgRect = svgOverlay.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return {
                x: clientX - svgRect.left,
                y: clientY - svgRect.top
            };
        }

        // --- Final Processing & Output ---
        function processCrop() {
            // Warp Perspective
            let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                cropPoints[0].x, cropPoints[0].y,
                cropPoints[1].x, cropPoints[1].y,
                cropPoints[2].x, cropPoints[2].y, // Note order in OpenCV might differ, adhering to sorted
                cropPoints[3].x, cropPoints[3].y
            ]);

            // Calculate width/height of new doc
            const w1 = Math.hypot(cropPoints[1].x - cropPoints[0].x, cropPoints[1].y - cropPoints[0].y);
            const w2 = Math.hypot(cropPoints[2].x - cropPoints[3].x, cropPoints[2].y - cropPoints[3].y);
            const h1 = Math.hypot(cropPoints[3].x - cropPoints[0].x, cropPoints[3].y - cropPoints[0].y);
            const h2 = Math.hypot(cropPoints[2].x - cropPoints[1].x, cropPoints[2].y - cropPoints[1].y);
            
            const finalW = Math.max(w1, w2);
            const finalH = Math.max(h1, h2);

            let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                0, 0,
                finalW, 0,
                finalW, finalH,
                0, finalH
            ]);

            let M = cv.getPerspectiveTransform(srcTri, dstTri);
            let dsize = new cv.Size(finalW, finalH);
            let dst = new cv.Mat();
            cv.warpPerspective(originalMat, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

            // Optional: Apply threshold (B&W filter)
            // cv.cvtColor(dst, dst, cv.COLOR_RGBA2GRAY);
            // cv.adaptiveThreshold(dst, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);

            // Render Result to store
            cv.imshow('hidden-canvas', dst);
            const finalImage = document.getElementById('hidden-canvas').toDataURL('image/jpeg', 0.8);
            
            addPage(finalImage);
            
            // Clean up
            srcTri.delete(); dstTri.delete(); M.delete(); dst.delete();
            if(originalMat) originalMat.delete();
        }

        function addPage(imgData) {
            scannedPages.push(imgData);
            updateGallery();
            switchView('view-home');
        }

        function updateGallery() {
            const grid = document.getElementById('gallery-grid');
            const empty = document.getElementById('empty-msg');
            const counter = document.getElementById('page-counter');
            
            if (scannedPages.length > 0) empty.style.display = 'none';
            else empty.style.display = 'block';

            counter.innerText = `${scannedPages.length} P치ginas`;
            
            // Simple re-render (in production, use append for performance)
            grid.innerHTML = '';
            grid.appendChild(empty); // keep ref
            
            scannedPages.forEach((src, idx) => {
                const card = document.createElement('div');
                card.className = 'thumb-card';
                card.innerHTML = `<img src="${src}">`;
                grid.appendChild(card);
            });
        }

        function retakePhoto() {
            if(originalMat) originalMat.delete();
            startCamera();
        }

        // --- PDF Generation ---
        function generatePDF() {
            if (scannedPages.length === 0) {
                alert("Escanea al menos una p치gina.");
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            scannedPages.forEach((imgData, i) => {
                if (i > 0) doc.addPage();
                
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                
                // Add Image scaling to fit A4
                doc.addImage(imgData, 'JPEG', 0, 0, pageWidth, pageHeight, undefined, 'FAST');
            });

            doc.save('documento_escaneado.pdf');
        }

    </script>
</body>
</html>
