<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Scanner Pro Web</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --accent: #00e5ff;
            --bg: #0f172a;
            --surface: #1e293b;
            --text: #f8fafc;
            /* Altura dinámica para corregir bug de Safari */
            --app-height: 100dvh; 
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; padding: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            height: var(--app-height);
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- Header --- */
        .app-header {
            height: 60px;
            padding: 0 15px;
            background: var(--surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 20;
            flex-shrink: 0; /* Evita que el header se aplaste */
            padding-top: env(safe-area-inset-top); /* Notch support */
        }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
        }
        .btn.secondary { background: #475569; }
        .btn.accent { background: var(--accent); color: #000; }

        /* --- Vistas --- */
        .view {
            flex: 1;
            display: none;
            flex-direction: column;
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .view.active { display: flex; }

        /* --- Home: Galería --- */
        #gallery-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            overflow-y: auto;
            /* Espacio extra abajo para los botones flotantes */
            padding-bottom: 120px; 
        }

        .thumb-card {
            background: var(--surface);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            aspect-ratio: 1/1.4;
            border: 1px solid #334155;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .thumb-card img { width: 100%; height: 100%; object-fit: cover; }
        
        .empty-state {
            position: absolute;
            top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #64748b;
            width: 80%;
        }

        /* Botones Flotantes (Home) */
        .fab-container {
            position: absolute;
            bottom: 30px;
            right: 20px;
            display: flex;
            gap: 15px;
            /* Corrección clave para iPhone X/11/12/13/14/15 */
            padding-bottom: env(safe-area-inset-bottom);
            z-index: 30;
        }
        .fab {
            width: 60px; height: 60px;
            border-radius: 50%;
            border: none;
            background: var(--accent);
            color: #000;
            font-size: 28px;
            box-shadow: 0 4px 15px rgba(0,0,0, 0.4);
            display: flex; align-items: center; justify-content: center;
        }

        /* --- Cámara --- */
        #video-container {
            flex: 1;
            position: relative;
            background: black;
            overflow: hidden;
        }
        #video-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .camera-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            /* Fondo degradado para legibilidad */
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            display: flex;
            justify-content: space-around;
            align-items: center;
            /* SAFE AREA FIX */
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
        }

        .capture-btn {
            width: 72px; height: 72px;
            border-radius: 50%;
            border: 4px solid white;
            background: rgba(255,255,255,0.2);
            transition: transform 0.1s;
        }
        .capture-btn:active { transform: scale(0.9); background: white; }

        /* --- Editor --- */
        #editor-container {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Importante: Evita que la imagen se salga en pantallas pequeñas */
        #image-canvas {
            max-width: 95%; 
            max-height: 95%;
            display: block;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #overlay-svg {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .selection-polygon {
            fill: rgba(0, 229, 255, 0.2);
            stroke: var(--accent);
            stroke-width: 2;
            vector-effect: non-scaling-stroke;
        }

        .crop-handle {
            fill: var(--accent);
            stroke: #fff;
            stroke-width: 3;
            r: 12; /* Radio más grande para dedos */
            pointer-events: all;
            transition: r 0.2s;
        }
        .crop-handle:active { r: 18; fill: #fff; }

        /* Footer del Editor - Elevado para Safari */
        .editor-footer {
            height: auto;
            min-height: 70px;
            background: var(--surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            /* SAFE AREA FIX */
            padding-bottom: calc(15px + env(safe-area-inset-bottom));
            z-index: 20;
        }

        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(15, 23, 42, 0.95);
            z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.1);
            border-left-color: var(--accent); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 15px;">Cargando Scanner...</p>
    </div>

    <div id="view-home" class="view active">
        <div class="app-header">
            <span style="font-weight:bold;">Scanner Pro</span>
            <span id="page-counter" style="font-size: 0.9em; opacity: 0.8;">0 Páginas</span>
        </div>
        
        <div id="gallery-grid">
            <div class="empty-state" id="empty-msg">
                <p>Presiona <b>+</b> para escanear documentos.</p>
            </div>
        </div>

        <div class="fab-container">
            <button class="fab" onclick="generatePDF()" style="background: #ef4444; color: white;" title="Crear PDF">
                <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
            </button>
            <button class="fab" onclick="startCamera()">
                <svg width="30" height="30" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 4v16m8-8H4"></path></svg>
            </button>
            <input type="file" id="file-input" accept="image/*" style="display:none" onchange="handleFileUpload(this)">
        </div>
    </div>

    <div id="view-camera" class="view">
        <div id="video-container">
            <video id="video-feed" autoplay playsinline></video>
        </div>
        <div class="camera-controls">
            <button class="btn secondary" onclick="document.getElementById('file-input').click()">
                <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" style="vertical-align: middle;"><path d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg> Galería
            </button>
            <button class="capture-btn" onclick="captureImage()"></button>
            <button class="btn secondary" onclick="switchView('view-home')">X</button>
        </div>
        <canvas id="hidden-canvas" style="display:none;"></canvas>
    </div>

    <div id="view-editor" class="view">
        <div class="app-header">
            <span>Ajustar Recorte</span>
        </div>
        
        <div id="editor-container">
            <canvas id="image-canvas"></canvas>
            <svg id="overlay-svg">
                <polygon id="crop-polygon" class="selection-polygon" points=""></polygon>
                <circle id="p0" class="crop-handle"></circle>
                <circle id="p1" class="crop-handle"></circle>
                <circle id="p2" class="crop-handle"></circle>
                <circle id="p3" class="crop-handle"></circle>
            </svg>
        </div>

        <div class="editor-footer">
            <button class="btn secondary" onclick="retakePhoto()">Reintentar</button>
            <button class="btn accent" onclick="processCrop()" style="min-width: 120px;">
                Guardar
            </button>
        </div>
    </div>

    <script>
        // --- Estado Global ---
        let cvReady = false;
        let scannedPages = [];
        let currentStream = null;
        let originalMat = null;
        let displayedScale = 1;
        
        // Coordenadas de Recorte (Normalizadas a tamaño real de imagen)
        let cropPoints = [{x:0, y:0}, {x:0, y:0}, {x:0, y:0}, {x:0, y:0}];
        let activeHandleIndex = -1;

        // --- Inicialización ---
        function onOpenCvReady() {
            cvReady = true;
            document.getElementById('loader').style.display = 'none';
        }

        function switchView(viewId) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            
            if (viewId !== 'view-camera' && currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
        }

        // --- Cámara ---
        async function startCamera() {
            if (!cvReady) { alert("Cargando motor de visión..."); return; }
            switchView('view-camera');
            
            try {
                // Constraints para pedir la mejor cámara trasera
                const constraints = {
                    video: {
                        facingMode: { ideal: "environment" },
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                document.getElementById('video-feed').srcObject = currentStream;
            } catch (err) {
                alert("Error de cámara: " + err.message + ". Intenta usar 'Galería'.");
            }
        }

        function handleFileUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => initEditor(img);
                    img.src = e.target.result;
                };
                reader.readAsDataURL(input.files[0]);
            }
            // Reset input
            input.value = '';
        }

        function captureImage() {
            const video = document.getElementById('video-feed');
            const canvas = document.getElementById('hidden-canvas');
            // Fijar resolución del canvas a la del video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            const img = new Image();
            img.onload = () => initEditor(img);
            img.src = canvas.toDataURL('image/jpeg');
        }

        // --- Lógica de Visión (AUTO DETECCIÓN MEJORADA) ---
        function initEditor(imageObj) {
            switchView('view-editor');
            
            if(originalMat) originalMat.delete();
            originalMat = cv.imread(imageObj);
            
            // 1. Detectar bordes automáticamente
            cropPoints = detectDocument(originalMat);

            // 2. Renderizar
            renderEditorCanvas(imageObj);
        }

        function detectDocument(src) {
            let dst = new cv.Mat();
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let edges = new cv.Mat();
            let kernel = cv.Mat.ones(5, 5, cv.CV_8U); // Kernel para morfología

            try {
                // Pre-procesamiento
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                
                // Canny Edge Detection
                cv.Canny(blurred, edges, 75, 200);

                // Paso extra: Dilatar para cerrar huecos en líneas
                cv.dilate(edges, edges, kernel);

                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let maxArea = 0;
                let biggestContour = null;

                // Buscar el contorno cuadrilátero más grande
                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    
                    // Filtrar ruido pequeño
                    if (area > 5000) { 
                        let peri = cv.arcLength(cnt, true);
                        let approx = new cv.Mat();
                        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

                        if (area > maxArea && approx.rows === 4) {
                            maxArea = area;
                            biggestContour = approx.clone(); // Guardar copia
                        }
                        approx.delete();
                    }
                }

                let resultPoints;

                if (biggestContour) {
                    // Si encontramos un cuadrado
                    let pts = [];
                    for(let i=0; i<4; i++) {
                        pts.push({
                            x: biggestContour.data32S[i*2],
                            y: biggestContour.data32S[i*2 + 1]
                        });
                    }
                    resultPoints = sortPoints(pts);
                    biggestContour.delete();
                } else {
                    // Fallback: Si falla, seleccionamos toda la imagen con un pequeño margen
                    const w = src.cols;
                    const h = src.rows;
                    const m = 20; // Margen
                    resultPoints = [
                        {x: m, y: m},          // TL
                        {x: w-m, y: m},        // TR
                        {x: w-m, y: h-m},      // BR
                        {x: m, y: h-m}         // BL
                    ];
                }

                // Limpieza de memoria
                contours.delete(); hierarchy.delete(); 
                gray.delete(); blurred.delete(); edges.delete(); dst.delete(); kernel.delete();

                return resultPoints;

            } catch (e) {
                console.error("Error CV:", e);
                // Retornar cuadro completo en caso de error
                return [{x:0,y:0}, {x:src.cols,y:0}, {x:src.cols,y:src.rows}, {x:0,y:src.rows}];
            }
        }

        // Ordenar puntos: TopLeft, TopRight, BottomRight, BottomLeft
        function sortPoints(pts) {
            pts.sort((a,b) => a.y - b.y);
            let top = pts.slice(0, 2).sort((a,b) => a.x - b.x);
            let bottom = pts.slice(2, 4).sort((a,b) => a.x - b.x);
            return [top[0], top[1], bottom[1], bottom[0]];
        }

        // --- Renderizado del Editor ---
        function renderEditorCanvas(imageObj) {
            const canvas = document.getElementById('image-canvas');
            const container = document.getElementById('editor-container');
            const svg = document.getElementById('overlay-svg');
            
            // Lógica de ajuste "Fit Contain"
            const maxWidth = container.clientWidth;
            const maxHeight = container.clientHeight;
            
            const scaleX = maxWidth / imageObj.width;
            const scaleY = maxHeight / imageObj.height;
            displayedScale = Math.min(scaleX, scaleY) * 0.95; // 95% para dejar margen

            canvas.width = imageObj.width * displayedScale;
            canvas.height = imageObj.height * displayedScale;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(imageObj, 0, 0, canvas.width, canvas.height);

            // Centrar el canvas visualmente
            svg.style.width = canvas.width + 'px';
            svg.style.height = canvas.height + 'px';
            svg.style.left = (container.clientWidth - canvas.width) / 2 + 'px';
            svg.style.top = (container.clientHeight - canvas.height) / 2 + 'px';
            
            canvas.style.marginLeft = svg.style.left;
            canvas.style.marginTop = svg.style.top;

            updateOverlayGraphics();
        }

        function updateOverlayGraphics() {
            const polyString = cropPoints.map(p => 
                `${p.x * displayedScale},${p.y * displayedScale}`
            ).join(" ");
            
            document.getElementById('crop-polygon').setAttribute("points", polyString);

            for(let i=0; i<4; i++) {
                const handle = document.getElementById('p'+i);
                handle.setAttribute("cx", cropPoints[i].x * displayedScale);
                handle.setAttribute("cy", cropPoints[i].y * displayedScale);
            }
        }

        // --- Eventos Táctiles (UI Editor) ---
        const svgOverlay = document.getElementById('overlay-svg');
        
        const onStart = (e) => {
            e.preventDefault(); // Prevenir scroll en safari
            const {x, y} = getEventCoords(e);
            let minDist = 40; // Radio de toque generoso
            
            cropPoints.forEach((p, i) => {
                const px = p.x * displayedScale;
                const py = p.y * displayedScale;
                const dist = Math.hypot(px - x, py - y);
                if (dist < minDist) {
                    minDist = dist;
                    activeHandleIndex = i;
                }
            });
        };

        const onMove = (e) => {
            if (activeHandleIndex === -1) return;
            e.preventDefault();
            const {x, y} = getEventCoords(e);
            
            // Actualizar coordenadas (limitadas al borde de la imagen)
            let newX = x / displayedScale;
            let newY = y / displayedScale;
            
            // Clamp (evitar salir de la imagen)
            newX = Math.max(0, Math.min(originalMat.cols, newX));
            newY = Math.max(0, Math.min(originalMat.rows, newY));

            cropPoints[activeHandleIndex].x = newX;
            cropPoints[activeHandleIndex].y = newY;
            updateOverlayGraphics();
        };

        const onEnd = () => activeHandleIndex = -1;

        svgOverlay.addEventListener('touchstart', onStart, {passive: false});
        svgOverlay.addEventListener('touchmove', onMove, {passive: false});
        svgOverlay.addEventListener('touchend', onEnd);
        
        svgOverlay.addEventListener('mousedown', onStart);
        svgOverlay.addEventListener('mousemove', onMove);
        svgOverlay.addEventListener('mouseup', onEnd);

        function getEventCoords(e) {
            const rect = svgOverlay.getBoundingClientRect();
            let cx, cy;
            if (e.touches && e.touches.length) {
                cx = e.touches[0].clientX;
                cy = e.touches[0].clientY;
            } else {
                cx = e.clientX;
                cy = e.clientY;
            }
            return { x: cx - rect.left, y: cy - rect.top };
        }

        // --- Procesar y Guardar ---
        function processCrop() {
            // Homografía (Transformación de perspectiva)
            let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                cropPoints[0].x, cropPoints[0].y,
                cropPoints[1].x, cropPoints[1].y,
                cropPoints[2].x, cropPoints[2].y,
                cropPoints[3].x, cropPoints[3].y
            ]);

            // Calcular ancho/alto final basados en la geometría detectada
            const wTop = Math.hypot(cropPoints[1].x - cropPoints[0].x, cropPoints[1].y - cropPoints[0].y);
            const wBot = Math.hypot(cropPoints[2].x - cropPoints[3].x, cropPoints[2].y - cropPoints[3].y);
            const hLeft = Math.hypot(cropPoints[3].x - cropPoints[0].x, cropPoints[3].y - cropPoints[0].y);
            const hRight = Math.hypot(cropPoints[2].x - cropPoints[1].x, cropPoints[2].y - cropPoints[1].y);
            
            const finalW = Math.max(wTop, wBot);
            const finalH = Math.max(hLeft, hRight);

            let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0,0, finalW,0, finalW,finalH, 0,finalH]);
            let M = cv.getPerspectiveTransform(srcTri, dstTri);
            let dst = new cv.Mat();
            
            // Warp
            cv.warpPerspective(originalMat, dst, M, new cv.Size(finalW, finalH));

            // Filtro estilo Scanner (Opcional: Binarización)
            // Para mantener color pero mejorar contraste:
            cv.cvtColor(dst, dst, cv.COLOR_RGBA2RGB); // Quitar alpha

            cv.imshow('hidden-canvas', dst);
            const res = document.getElementById('hidden-canvas').toDataURL('image/jpeg', 0.85);
            
            scannedPages.push(res);
            updateGallery();
            switchView('view-home');

            // Cleanup
            srcTri.delete(); dstTri.delete(); M.delete(); dst.delete();
            if(originalMat) originalMat.delete(); originalMat = null;
        }

        function updateGallery() {
            const grid = document.getElementById('gallery-grid');
            const empty = document.getElementById('empty-msg');
            const counter = document.getElementById('page-counter');
            
            empty.style.display = scannedPages.length ? 'none' : 'block';
            counter.innerText = `${scannedPages.length} Página(s)`;
            
            // Reconstrucción simple
            grid.innerHTML = '';
            grid.appendChild(empty);
            
            scannedPages.forEach((src, idx) => {
                const d = document.createElement('div');
                d.className = 'thumb-card';
                d.innerHTML = `<img src="${src}">`;
                grid.appendChild(d);
            });
        }

        function retakePhoto() {
            if(originalMat) { originalMat.delete(); originalMat = null; }
            startCamera();
        }

        function generatePDF() {
            if (!scannedPages.length) return alert("Escanea algo primero.");
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            scannedPages.forEach((img, i) => {
                if(i>0) doc.addPage();
                const props = doc.getImageProperties(img);
                const pdfW = doc.internal.pageSize.getWidth();
                const pdfH = (props.height * pdfW) / props.width; // Mantener ratio
                doc.addImage(img, 'JPEG', 0, 0, pdfW, pdfH);
            });
            
            doc.save('scan_' + new Date().getTime() + '.pdf');
        }
    </script>
</body>
</html>
