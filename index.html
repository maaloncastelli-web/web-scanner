<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Scanner Pro V4 - High Precision</title>
    
    <script src="https://docs.opencv.org/4.7.0/opencv.js" async onload="onOpenCvReady();"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            margin: 0; background: #000; color: white; 
            height: 100dvh; width: 100vw; overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex; flex-direction: column;
        }

        /* 츼rea Visual */
        #viewport {
            position: relative; flex: 1; width: 100%; overflow: hidden;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #canvasOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Debug View: Peque침a ventana para ver c칩mo procesa la IA */
        #debugCanvas {
            position: absolute; top: 10px; right: 10px; 
            width: 100px; height: auto; 
            border: 1px solid lime; background: black;
            z-index: 50; display: none; /* Oculto por defecto */
        }

        /* UI */
        #hud {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
            padding-bottom: env(safe-area-inset-bottom, 20px);
            display: flex; flex-direction: column; gap: 15px; z-index: 20;
        }

        #gallery {
            display: flex; gap: 10px; overflow-x: auto; padding: 0 20px;
            height: 70px; align-items: center;
        }
        .thumb { height: 60px; border-radius: 4px; border: 2px solid #555; transition: 0.2s; }
        .thumb.new { border-color: #00e676; transform: scale(1.1); }

        .controls { display: flex; justify-content: space-around; align-items: center; padding: 10px 20px 20px; }
        
        .btn {
            background: rgba(255,255,255,0.15); border: none; color: white;
            border-radius: 30px; padding: 10px 18px; font-weight: 600; font-size: 13px;
            backdrop-filter: blur(5px);
        }
        
        .shutter-ring {
            width: 70px; height: 70px; border-radius: 50%;
            border: 4px solid white; display: flex; justify-content: center; align-items: center;
        }
        .shutter-core {
            width: 58px; height: 58px; background: white; border-radius: 50%;
            transition: 0.1s;
        }
        .shutter-ring:active .shutter-core { transform: scale(0.85); background: #ddd; }

        #msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7); padding: 15px 25px; border-radius: 8px;
            text-align: center; font-size: 14px; pointer-events: none; display: none;
        }
    </style>
</head>
<body>

<div id="viewport">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvasOverlay"></canvas>
    <canvas id="debugCanvas"></canvas>
    <div id="msg">Iniciando c치mara...</div>
</div>

<div id="hud">
    <div id="gallery"></div>
    <div class="controls">
        <button class="btn" onclick="toggleDebug()">游녜 Debug</button>
        <div class="shutter-ring" onclick="capture()">
            <div class="shutter-core"></div>
        </div>
        <button class="btn" style="background: #28a745;" onclick="makePDF()">游늯 PDF <span id="cnt">(0)</span></button>
    </div>
</div>

<script>
    const CONFIG = {
        processWidth: 800, // Aumentado para mejor detalle
        minArea: 10000,    // 츼rea m칤nima m치s exigente para reducir falsos positivos
    };

    let state = {
        cvReady: false,
        stream: null,
        pages: [],
        currContour: null,
        debugMode: false,
        busy: false
    };

    const video = document.getElementById('video');
    const overlay = document.getElementById('canvasOverlay');
    const debugCv = document.getElementById('debugCanvas');
    const ctxOv = overlay.getContext('2d');
    const msg = document.getElementById('msg');

    function showMsg(text) {
        msg.innerText = text;
        msg.style.display = 'block';
        setTimeout(() => msg.style.display = 'none', 2000);
    }

    function onOpenCvReady() {
        state.cvReady = true;
        showMsg("OpenCV Cargado");
        startCamera();
    }

    async function startCamera() {
        try {
            const constraints = { video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } } };
            state.stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = state.stream;
            video.onloadedmetadata = () => {
                video.play();
                requestAnimationFrame(loop);
            };
        } catch(e) { alert("Error C치mara: " + e); }
    }

    // --- BUCLE DE PROCESAMIENTO MEJORADO ---
    function loop() {
        if (!state.cvReady || video.paused || video.ended) { requestAnimationFrame(loop); return; }

        // 1. Setup y Escalado
        overlay.width = video.videoWidth; overlay.height = video.videoHeight;
        
        let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
        let cap = new cv.VideoCapture(video);
        cap.read(src);

        let small = new cv.Mat();
        let scale = CONFIG.processWidth / src.cols;
        cv.resize(src, small, new cv.Size(CONFIG.processWidth, src.rows * scale));

        // 2. PRE-PROCESAMIENTO ROBUSTO (La clave de la mejora)
        let gray = new cv.Mat();
        cv.cvtColor(small, gray, cv.COLOR_RGBA2GRAY);
        
        // Blur suave para ruido
        cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
        
        // Threshold Adaptativo en lugar de Canny
        // Esto convierte todo en blanco o negro s칩lido, mucho m치s f치cil de detectar
        let binary = new cv.Mat();
        cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
        
        // Erosi칩n + Dilataci칩n para eliminar ruido y cerrar bordes rotos
        // "Limpiamos" los puntos negros peque침os y reconectamos l칤neas blancas
        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.morphologyEx(binary, binary, cv.MORPH_OPEN, kernel); 
        // Borde Canny sobre la imagen binaria limpia
        let edges = new cv.Mat();
        cv.Canny(binary, edges, 50, 150);

        // 3. Si Debug est치 activo, mostramos la visi칩n binaria
        if (state.debugMode) {
            cv.imshow(debugCv, binary); 
            debugCv.style.display = 'block';
        } else {
            debugCv.style.display = 'none';
        }

        // 4. Detecci칩n de Contornos
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let bestCnt = null;
        let maxArea = 0;

        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);

            if (area > CONFIG.minArea) {
                let peri = cv.arcLength(cnt, true);
                let approx = new cv.Mat();
                // Epsilon m치s relajado (0.02 -> 0.03) permite bordes un poco curvos
                cv.approxPolyDP(cnt, approx, 0.03 * peri, true);

                if (approx.rows === 4 && area > maxArea) {
                    // Verificaci칩n extra: Convexidad
                    if (cv.isContourConvex(approx)) {
                        maxArea = area;
                        if (bestCnt) bestCnt.delete();
                        bestCnt = approx;
                    } else {
                        approx.delete();
                    }
                } else {
                    approx.delete();
                }
            }
        }

        // 5. Dibujar Overlay
        ctxOv.clearRect(0,0, overlay.width, overlay.height);
        
        if (bestCnt) {
            // Re-escalar puntos
            let pts = [];
            for(let i=0; i<4; i++) {
                pts.push({ x: bestCnt.data32S[i*2]/scale, y: bestCnt.data32S[i*2+1]/scale });
            }
            state.currContour = pts;

            // Dibujar Quad verde
            ctxOv.beginPath();
            ctxOv.lineWidth = 8;
            ctxOv.strokeStyle = '#00ff00';
            ctxOv.moveTo(pts[0].x, pts[0].y);
            for(let i=1; i<4; i++) ctxOv.lineTo(pts[i].x, pts[i].y);
            ctxOv.closePath();
            ctxOv.stroke();
            
            // Relleno semi-transparente
            ctxOv.fillStyle = 'rgba(0,255,0,0.2)';
            ctxOv.fill();

            bestCnt.delete();
        } else {
            state.currContour = null;
        }

        // Limpieza de Memoria (CR칈TICO)
        src.delete(); small.delete(); gray.delete(); binary.delete(); 
        kernel.delete(); edges.delete(); contours.delete(); hierarchy.delete();

        requestAnimationFrame(loop);
    }

    // --- CAPTURA ---
    function capture() {
        if (state.busy) return;
        state.busy = true;

        showMsg("Procesando...");
        if (navigator.vibrate) navigator.vibrate(100);

        setTimeout(() => {
            let canvas = document.createElement('canvas');
            canvas.width = video.videoWidth; canvas.height = video.videoHeight;
            let ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            let src = cv.imread(canvas);
            let dst = new cv.Mat();

            if (state.currContour) {
                // WARP
                let pts = sortPts(state.currContour);
                let w = Math.max(dist(pts[0], pts[1]), dist(pts[2], pts[3]));
                let h = Math.max(dist(pts[0], pts[3]), dist(pts[1], pts[2]));
                
                let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [pts[0].x, pts[0].y, pts[1].x, pts[1].y, pts[2].x, pts[2].y, pts[3].x, pts[3].y]);
                let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0,0, w,0, w,h, 0,h]);
                let M = cv.getPerspectiveTransform(srcTri, dstTri);
                
                cv.warpPerspective(src, dst, M, new cv.Size(w, h));
                srcTri.delete(); dstTri.delete(); M.delete();
            } else {
                src.copyTo(dst); // Foto normal si no detecta
            }

            // FILTER: Scan Effect
            cv.cvtColor(dst, dst, cv.COLOR_RGBA2GRAY);
            cv.adaptiveThreshold(dst, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 15, 12);

            cv.imshow(canvas, dst);
            state.pages.push(canvas.toDataURL("image/jpeg", 0.8));
            
            // UI Update
            let img = document.createElement('img');
            img.src = canvas.toDataURL();
            img.className = 'thumb new';
            document.getElementById('gallery').appendChild(img);
            document.getElementById('cnt').innerText = `(${state.pages.length})`;
            setTimeout(() => img.classList.remove('new'), 300);

            src.delete(); dst.delete();
            state.busy = false;
        }, 100);
    }

    function sortPts(pts) {
        pts.sort((a,b) => a.y - b.y);
        let t = pts.slice(0,2).sort((a,b) => a.x - b.x);
        let b = pts.slice(2,4).sort((a,b) => a.x - b.x);
        return [t[0], t[1], b[1], b[0]];
    }
    
    function dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }

    function toggleDebug() {
        state.debugMode = !state.debugMode;
        showMsg(state.debugMode ? "Debug: ON (Vista Binaria)" : "Debug: OFF");
    }

    async function makePDF() {
        if(!state.pages.length) return alert("Sin p치ginas");
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        for(let i=0; i<state.pages.length; i++) {
            let img = new Image(); img.src = state.pages[i];
            await new Promise(r => img.onload = r);
            let props = doc.getImageProperties(img);
            let pH = (props.height * doc.internal.pageSize.getWidth()) / props.width;
            if(i>0) doc.addPage();
            doc.addImage(state.pages[i], 'JPEG', 0, 0, doc.internal.pageSize.getWidth(), pH);
        }
        doc.save("Scan.pdf");
    }
</script>
</body>
</html>
